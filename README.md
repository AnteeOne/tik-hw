# ~~SNAIL~~  CBA  Archiver

## Запуск программы:

### - Открытие JAR:

```bash
java -jar TikTok.main.jar
```



![1](res\1.png)

### - Получение списка доступных команд:

```
/help
```



![1](res\2.png)

### Получение списка доступных команд:

Запуск алгоритма

```bash
 //COMMAND FILE_PATH
```



### Выход из программы:		

```
/exit
```



## Особбености реализации алгоритмов:

- FileService - сервис для работы с файлами, чтение и запись
- FrequencyService - еще один сервис, принимает в методах изначальный текст, умеет выдавать частоты символов в тексте, вероятности встречи символа в тексте, алфавит текста
- BinaryList - утилита, для удобной работы с битами, инвертирования бита, класс из 4-х и 7-ми битов (юзается в Хэмминге)
- Log - простая утилита для вывода логов в консоли
- Работал не напрямую с файлами, а со String и StringBuilder для тестирования на строках

### Расширения выходных файлов:

Формат выходных файлов:    `.decoded  ||  .encoded`

### Алгоритм  Хаффмена:

- Класс Node для реализации своего кодового дерева, каждый Node хранит в себе ссылку на левого и правого ребенка, а также символ, если Node - лист дерева

- Перед запуском алгоритма, проходимся по тексту и сохраняем частоты символов в HashMap, что бы потом доставать частоту нужного символа за O(1) 

- Создаем лист Node-ов без детей  

  ```java
  ArrayList<Node> encodedCodeNodes = symbolCounts
                  .keySet()
                  .stream()
                  .map(c -> new Node(c, symbolCounts.get(c)))
                  .collect(Collectors.toCollection(ArrayList::new));
  ```

- Запускам алгоритм Хаффмена, строим кодовое дерево:
  - Cортируем на каждой итерации алгоритма ноды
  - Объединяем две последний ноды в одну
  - Новая итерация
  - Получаем на выходе кодовое дерево
- Создаем HashMap nodesCodes из мапы частот и кодового дерева (будем доставать нужный код за O(1) )
- Записываем в файл:  каждый исходный char из текста достаем из HashMap nodesCodes и маппим в его кодовое представление

- Читаем из файла биты и мапу частот символов
- Снова создаем лист Node-ов без детей , строим дерево c помощью алгоса кодирования, декодируем текст:
  - Проходимся для каждого закодированного бита по дереву, когда доходим до листа - добавляем char в StringbBuilder	

### Алгоритм  Арифмитического Кодирования:

- Для определения отрезков будем использовать класс Segment, который хранит в себе левый и правый концы отрезка
- Для определения текущего подотрезка будем юзать BigDecimal left и BigDecimal right

### Алгоритм  BWT + MTF (Стопка Книг):

- Классы BwtEncodingTable и BwtDecodingTable - для упрощения работы с таблицей сдвигов, сортировки по строкам и столбцам
- Храним все сдвиги в ArrayList - е, сортируем
- На выходе кодировщик выдает объект класса BwtResult, который содержит в себе последний столбец и позицию начальной строки в отсортированной таблице
- Mtf кодировщик получает на вход алфавит текста, который вычисляется перед алгоритмом (Стринга из всех уникальных символов текста)
- На выход кодировщик отдает целочисленный список, который записывается в файл, а затем считывается декодировщиком

### Алгоритм  Хэмминга:

- Для каждых 4-х бит (x1,x2,x3,x4) из исходного текста считаем синдромы (p1,p2,p3) , добавляем в результирующий StringBuilder 7 битов (p1,p2,x1,p3,x2,x3,x4)

- Для этого используем вспомогательный класс FourBits()

- После алгоритма кодирования инвертируем рандомный бит, в псевдорандомный класс Random подаем seed = System.currentTimeMillis()

- В алгоритме декодирования для каждых 7-ми бит в тексте восстанавливаем исходные 4 бита:

  - Для этого используем вспомогательный класс SevenBits()

  - Заново считаем синдромы p1,p2,p3 и сравниваем со старыми синдромами из 7-ми бит , вычисляем позицию ошибки и исправляем ее (инвертируем этот бит) , если позиция == 0, то ошибки нету

  - Записываем 4 бита в новый файл

    ```javascript
    int p1 = (x3 + x5 + x7) % 2;
    int p2 = (x3 + x6 + x7) % 2;
    int p3 = (x5 + x6 + x7) % 2;
    
    int errorIndex = 0;
    if(p1 != x1) {
        errorIndex+=1;
    }
    if (p2 != x2) {
        errorIndex+=2;
    }
    if(p3 != x4 ) {
        errorIndex+=4;
    }
    return errorIndex;
    ```



